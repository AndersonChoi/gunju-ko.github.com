# 트랜잭션

#### 1. 트랜잭션 수준의 읽기 일관성 (Transaction-Level Read Consistency)

문장수준 읽기 일관성은 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어 들이는 것이다. **트랜잭션 수준 읽기 일관성은 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어 들이는 것이다.** 트랜잭션 수준으로 읽기 일관성을 강화하려면 트랜잭션 고립화 수준을 높여 주어야한다.

#### 2. 트랜잭션 고립화 수준

- LEVEL 0 : READ_UNCOMMITTED 

- - **다른 세션에서 변경중인 데이터를 읽을 수 있다.** 트랜잭션에서 처리중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
  - Dirty Read, Non-repeatable Read, Phantom Read 현상이 발생한다.

- LEVEL 1 : READ_COMMITTED

- - **트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용**
  - 대부분의 DBMS가 기본모드로 채택하고 있는 일관성 모드
  - Non-Repeatable Read, Phantom Read 현상 발생
  - DB2, SQL Server, Sybase의 경우 읽기 공유 Lock을 이용해서 구현, 하나의 레코드를 읽을 때 Lock을 설정하고 해당 레코드에서 빠지는 순간 Lock 해제
  - Oracle의 경우 Lock을 사용하지 않고 쿼리시작 시점의 Undo 데이터를 제공하는 방식으로 구현

- LEVEL 2 : REPEATABLE_READ 

- - 선형 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허함으로써 **같은 데이터를 두번 쿼리했을 때 일관성 있는 결과를 리턴**
  - Phantom Read 현상 발생

- LEVEL 3 : SERIALIZABLE

- - **선형 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌**
  - 완벽한 읽기 일관성 모드를 제공

#### Dirty Read

**커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생한다.** 대부분의 DBMS가 기본 트랜잭션 고립화 수준을 레벨 1로 설정하고 있어서 Dirty Read는 발생하지 않는다. 

#### Non-Repeatable Read

한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 **수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 말한다.**

#### Phantom Read

**한 트랜잭션 안에서 일정 범위의 레코드를 두번 이상 읽을때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상이다.** 이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타나는 현상이다. Phantom Read 현상을 방지하려면 트랜잭션 고립화 수준을 SERIALIZABLE으로 올려야 한다. 고립화 수준을 높이면 데이터 일관성은 확보 되지만 동시성이 현격히 저하되는 결과를 초래한다.

>  **트랜잭션 고립화 수준을 높이면 일관성(Consistency)은 향상 되지만 더 높은 범위의 Lock을 더 오랫동안 유지하는 방식으로 동시성(Consistency)을 저하한다.**

트랜잭션 전파와 격리 레벨

현재 진행중인 트랜잭션이 있는 상태에서 새로운 트랜잭션을 시작하고 싶다면 어떻게 해야할까? JDBC를 이용한다면, 아마도 새로운 커넥션을 가져와 트랜잭션을 시작할 것이다.

**스프링은 새로운 트랜잭션을 새로 생성하는 것뿐만 아니라 기존 트랜잭션을 그대로 사용하거나 기존에 트랜잭션이 진행중인 상태에서 현재 코드를 실행하는 등의 트랜잭션 전파와 관련된 부분을 설정으로 지정할 수 있도록 지원하고 있다.** 실제 설정에서 사용하는 값은 사용할 트랜잭션 지원 방식에 따라 조금씩 다르다. 예를 들어 TransactionTemplate에서는 PROPAGATION_REQUIRED를 값으로 사용하는 반면에 <tx:advice> 태그에서는 REQUIRED를 사용한다.

## Spring 트랜잭션 속성

@Transactional 애노테이션의 엘리먼트로 트랜잭션 속성을 지정할 수 있음

### 읽기전용 트랜잭션 : readOnly

* 성능 최적화 or 쓰기 작업을 방지
* 트랜잭션 매니저 구현에 따라 읽기 전용 속성이 무시될 수 있음
* 일반적으로는 INSERT, UPDATE, DELETE시에 예외가 발생

### 트랜잭션 롤백 예외 : rollbackFor, rollbackForClassName

* 런타임 예외시 롤백한다.
  * 예외가 전혀 발생하지 않거나 체크 예외가 발생하면 커밋
* 체크 예외가 커밋 대상으로 삼은 이유는? 체크 예외는 비즈니스적인 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문 + 스프링에서는 데이터 액세스 기술의 예외는 런타임 예외로 전환해서 던지지니깐
* 체크 예외지만 롤백 대상으로 삼고 싶다면? rollbackFor 엘리먼트 사용 또는 rollbackForClassName 엘리먼트 사용

### 트랜잭션 제한시간: timeout

* 트랜잭션 제한시간을 지정할 수 있음 (값은 초 단위로 지정)
* 디폴트는 트랜잭션 시스템의 제한시간을 따르는 것

### 트랜잭션 커밋 예외 : noRollbackFor, noRollbackForClassName

* rollback-for 속성과는 반대로 런타임 예외를 트랜잭션 커밋 대상으로 지정할 때 사용

### 트랜잭션 전파 속성 : propagation

트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성. 총 7가지 속성이 있는데 모든 속성이 모든 종류의 트랜잭션 매니저와 데이터 액세스 기술에서 다 지원되진 않음 (주의)

- REQUIRED : 현재 진행중인 트랜잭션이 존재하면 해당 트랜잭션을 사용한다. 존재하지 않는다면 새로운 트랜잭션을 생성한다.
  - 대부분 이 속성 사용 + 기본값
- MANDATORY : 이미 시작된 트랜잭션이 있으면 참여한다. 없으면 Exception을 발생
  - 혼자서는 독립적으로 트랜잭션을 진행하면 안되는 경우 사용
- REQUIRES_NEW : 항상 새로운 트랜잭션을 시작한다. 기존 트랜잭션이 존재하면 기존 트랜잭션을 일시 중지하고 새로운 트랜잭션을 시작한다. 새로 시작된 트랜잭션이 종료된 뒤에 기존 트랜잭션이 계속된다.
- SUPPORTS : 메소드가 트랜잭션을 필요로 하지는 않지만, 기존 트랜잭션이 존재할 경우 트랜잭션을 사용한다.
  - 트랜잭션이 없긴 하지만 해당 경계 안에서 Connection이나 하이버네이트 Session등을 공유할 수 있음
- NOT_SUPPORTED : 메소드가 트랜잭션을 필요로 하지  않는다. (진행중인 트랜잭션이 존재할 경우 트랜잭션은 일시 중지 되며, 메소드 실행이 종료된 후에 트랜잭션을 계속 진행한다.)
- NEVER : 메소드가 트랜잭션을 필요로 하지 않는다. (만약 진행중인 트랜잭션이 존재하면 익셉션이 발생한다)
- NESTED : 기존 트랜잭션이 존재하면, 기존 트랜잭션에 중첩된 트랜잭션에서 메소드를 실행한다. 기존 트랜잭션이 없으면 새로운 트랜잭션을 실행한다.
  - 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다. 중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만, 자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다.
  - 부모 트랜잭션이 롤백되면 중첩 트랜잭션도 같이 롤백되지만, 반대로 중첩 트랜잭션이 롤백돼도 부모 트랜잭션은 영향을 받진 않고 정상적으로 커밋된다.
  - 유용한 트랜잭션 전파 방식이지만 모든 트랜잭션 매니저에 다 적용 가능한 건 아니므로, 적용하려면 사용할 트랜잭션 매니저와 드라이버 WAS의 문서를 참조해보고 미리 학습 테스트를 만들어서 검증해봐야 한다.

### 트랜잭션 격리 레벨 : isolation

격리 수준은 동시에 여러 트랜잭션이 진행될 때 트랜잭션의 작업 결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정하는 기준임. 5가지 격리수준 속성을 지원함

- DEFAULT : 사용하는 데이터액세스 기술 또는 DB 드라이버의 디폴트 설정을 따름
  - 보통 드라이버의 격리수준은 DB의 격리수준을 다르는게 일반적임 (대부분 READ_COMMITTED)
- READ_UNCOMMITED : 다른 트랜잭션에서 커밋하지 않은 데이터를 읽을 수 있다.
  - 가장 낮은 격리수준 => 성능 극대화시 사용
- READ_COMMITED : 다른 트랜잭션에 의해 커밋된 데이터를 읽을 수 있다.
  - 가장 많이 사용됨
  - DB의 기본 격리수준이 READ_COMMITTED인 경우가 많기 때문에 따로 설정되지 않아도 대부분 READ_COMMITTED로 동작
  - 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정 가능 => NON-REAPTABLE READ가 발생할 수 있음
- REPEATABLE_READ : 처음에 읽어 온 데이터와 두 번째 읽어 온 데이터가 동일한 값을 갖는다.
  - 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정하는 것을 막는다.
  - 새로운 로우는 추가할 수 있다. => PHANTOM READ 발생
- SERIALIZATION : 동일한 데이터에 대해서 동시에 2개 이상의 트랜잭션이 수행될 수 없다.
  - 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스하지 못함
  - 성능 매우 안좋음



